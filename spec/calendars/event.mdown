# Calendar Events

A **CalendarEvent** object contains information about an event, or recurring series of events, that takes place at a particular time. It is a JSEvent object, as defined in [@!RFC8984], with the following additional properties:

- **id**: `Id` (immutable; server-set)
  The id of the CalendarEvent. The id uniquely identifies a JSEvent with a particular "uid" and "recurrenceId" within a particular account.

- **baseEventId**: `Id|null` (immutable; server-set)
  This is only defined if the *id* property is a synthetic id, generated by the server to represent a particular instance of a recurring event (see Section XXX). This property gives the id of the "real" CalendarEvent this was generated from.

- **calendarIds**: `Id[Boolean]`
  The set of Calendar ids this event belongs to. An event MUST belong to one or more Calendars at all times (until it is destroyed). The set is represented as an object, with each key being a *Calendar id*. The value for each key in the object MUST be `true`.

- **isDraft**: `Boolean` (default: false)
  If true, this event is to be considered a draft. The server will not send any scheduling messages to participants or send push notifications for alerts. This may only be set to true upon creation. Once set to false, the value cannot be updated to true. This property MUST NOT appear in "recurrenceOverrides".

- **isOrigin**: `Boolean` (server-set)
  Is this the authoritative source for this event (i.e., does it control
  scheduling for this event; the event has not been added as a result of an
  invitation from another calendar system)? This is `true` if, and only if:

    * the event's "replyTo" property is `null`; or
    * the account will receive messages sent to at least one of the methods
      specified in the "replyTo" property of the event.

- **utcStart**: `UTCDate`
  For simple clients that do not or cannot implement time zone support. Clients should only use this if also asking the server to expand recurrences, as you cannot accurately expand a recurrence without the original time zone.

    This property is calculated at fetch time by the server. Time zones are political and they can and do change at any time. Fetching exactly the same property again may return a different results if the time zone data has been updated on the server. Time zone data changes are not considered "updates" to the event.

    If set, the server will convert the UTC date to the event's current time zone and store the local time.

    This is not included by default and must be requested explicitly.

    Floating events (events without a time zone) will be interpreted as per the time zone given as a CalendarEvent/get argument.

    Note that it is not possible to accurately calculate the expansion of recurrence rules or recurrence overrides with the utcStart property rather than the local start time. Even simple recurrences such as "repeat weekly" may cross a daylight-savings boundary and end up at a different UTC time. Clients that wish to use "utcStart" are RECOMMENDED to request the server expand recurrences (see Section XXX).

- **utcEnd**: `UTCDate`
  The server calculates the end time in UTC from the start/timeZone/duration properties of the event. This is not included by default and must be requested explicitly. Like utcStart, this is calculated at fetch time if requested and may change due to time zone data changes. Floating events will be interpreted as per the time zone given as a CalendarEvent/get argument.

CalendarEvent objects MUST NOT have a "method" property as this is only used when representing iTIP [@!RFC5546] scheduling messages, not events in a data store.

## Additional JSCalendar properties

This document defines three new JSCalendar properties for common use.

### mayInviteSelf

Type: `Boolean` (default: false)

If `true`, any user may add themselves to the event as a participant with the "attendee" role. This property MUST NOT be altered in the recurrenceOverrides; it may only be set on the base object.

This indicates the event will accept "party crasher" RSVPs via iTIP, subject to any other domain-specific restrictions, and users may add themselves to the event via JMAP as long as they have the mayRSVP permission for the calendar.

### mayInviteOthers

Type: `Boolean` (default: false)

If `true`, any current participant with the "attendee" role may add new participants with the "attendee" role to the event. This property MUST NOT be altered in the recurrenceOverrides; it may only be set on the base object.

The mayRSVP permission for the calendar is also required in conjunction with this event property for users to be allowed to make this change via JMAP.

### hideAttendees

Type: `Boolean` (default: false)

If `true`, only the owners of the event may see the full set of participants. Other sharees of the event may only see the owners and themselves. This property MUST NOT be altered in the recurrenceOverrides; it may only be set on the base object.

## Attachments

The Link object, as defined in [@!RFC8984] Section 4.2.7, with a "rel" property equal to "enclosure" is used to represent attachments. Instead of mandating an "href" property, clients may set a "blobId" property instead to reference a blob of binary data in the account, as per [@!RFC8620] Section 6.

The server MUST translate this to an embedded `data:` URL [@!RFC2397] when sending the event to a system that cannot access the blob. Servers that support CalDAV access to the same data are recommended to expose these files as managed attachments [?@RFC8607].

## Per-user properties

In shared calendars, any top-level property registered in the IANA registry as "Is Per-User: yes" (see Section XXX) MUST be stored per-user. This includes:

- keywords
- color
- freeBusyStatus
- useDefaultAlerts
- alerts

The user may also modify these properties on a per-occurrence basis for recurring events; again, these MUST be stored per-user. Sharees initially receive the default value for each of these properties, not whatever value another user may have set.

When writing only per-user properties, the "updated" property MUST also be stored just for that user if set. When fetching the "updated" property, the value to return is whichever is later of the per-user updated time or the updated time of the base event.

## Recurring events

Events may recur, in which case they represent multiple occurrences or instances. The data store will either contain a single base event, containing a recurrence rule and/or recurrence overrides; or, a set of individual instances (when invited to specific occurrences only).

The client may ask the server to expand recurrences within a specific time range in "CalendarEvent/query". This will generate synthetic ids representing individual instances in the requested time range. The client can fetch and update the objects using these ids and the server will make the appropriate changes to the base event. Synthetic ids do not appear in "CalendarEvent/changes" responses; only the ids of events as actually stored on the server.

If the user is invited to specific instances then later added to the base event, "CalendarEvent/changes" will show the ids of all the individual instances being destroyed and the id for the base event being created.

## Updating for "this-and-future"

When editing a recurring event, you can either update the base event (affecting all instances unless overriden) or update an override for a specific occurrence. To update all occurrences from a specific point onwards, there are therefore two options: split the event, or update the base event and override all occurrences before the split point back to their original values.

### Splitting an event

If the event is not scheduled (has no participants), the simplest thing to do is to duplicate the event, modifying the recurrence rules of the original so it finishes before the split point, and the duplicate so it starts at the split point. As per JSCalendar [@!RFC8984] Section 4.1.3, a "next" and "first" relation MUST be set on the new objects respectively.

Splitting an event however is problematic in the case of a scheduled event, because the iTIP messages generated make it appear like two unrelated changes, which can be confusing.

### Updating the base event and overriding previous

For scheduled events, a better approach is to avoid splitting and instead update the base event with the new property value for "this and future", then create overrides for all occurrences before the split point to restore the property to its previous value. Indeed, this may be the only option the user has permission to do if not an owner of the event.

Clients may choose to skip creating the overrides if the old data is not important, for example if the "alerts" property is being updated, it is probably not important to create overrides for events in the past with the alerts that have already fired.

## CalendarEvent/get

This is a standard "/get" method as described in [@!RFC8620], Section 5.1, with three extra arguments:

- **recurrenceOverridesBefore**: `UTCDate|null`
  If given, only recurrence overrides with a recurrence id before this date (when translated into UTC) will be returned.
- **recurrenceOverridesAfter**: `UTCDate|null`
  If given, only recurrence overrides with a recurrence id on or after this date (when translated into UTC) will be returned.
- **reduceParticipants**: `Boolean` (default: false)
  If true, only participants with the "owner" role or corresponding to the user's participant identities will be returned in the "participants" property of the base event and any recurrence overrides. If false, all participants will be returned.
- **timeZone**: `String` (default "Etc/UTC")
  The time zone to use when calculating the utcStart/utcEnd property of floating events. This argument has no effect if those properties are not requested.

A CalendarEvent object is a JSEvent object so may have arbitrary properties. If the client makes a "CalendarEvent/get" call with a null or omitted "properties" argument, all properties defined on the JSEvent object in the store are returned, along with the "id", "calendarIds", "isDraft", and "isOrigin" properties. The "utcStart" and "utcEnd" computed properties are only returned if explicitly requested. If either are requested, the "recurrenceOverrides" property MUST NOT be requested (recurrence overrides cannot be interpreted accurately with just the UTC times).

If specific properties are requested from the JSEvent and the property is not present on the object in the server's store, the server SHOULD return the default value if known for that property.

A requested id may represent a server-expanded single instance of a recurring event if the client asked the server to expand recurrences in "CalendarEvent/query". In such a case, the server will resolve any overrides and set the appropriate "start" and "recurrenceId" properties on the CalendarEvent object returned to the client. The "recurrenceRule" and "recurrenceOverrides" properties MUST be returned as null if requested for such an event.

An event with the same uid/recurrenceId may appear in different accounts. Clients may coalesce the view of such events, but must be aware that the data may be different in the different accounts due to per-user properties, difference in permissions, etc.

The "hideAttendees" property of a JSEvent object allows the event owner(s) to reduce the visibility of sharees into the set of participants. If this is true, when a non-owner sharee fetches the event, the server MUST only return participants with the "owner" role or corresponding to the user's participant identities.

The "privacy" property of a JSEvent object allows the principal that owns the calendar to override how sharees of the calendar see the event. If set to "private", then when a sharee fetches the event the server MUST only return properties that are:

* the basic time and metadata properties of the JSEvent object as specified in
  [@!RFC8984], Section 4.4.3; or
* properties that are wholly derived from these permitted properties
  (i.e., utcStart, utcEnd); or
* Additional CalendarEvent properties not derived from the JSEvent data
  (i.e., id, baseEventId, calendarIds, isDraft, isOrigin).

If "privacy" is set to "secret", the server MUST behave as though the event does not exist for all users other than the principal that owns the calendar.

## CalendarEvent/changes

This is a standard "/changes" method as described in [@!RFC8620], Section 5.2.

Synthetic ids generated by the server expanding recurrences in "CalendarEvent/query" do not appear in "CalendarEvent/changes" responses; only the ids of events as actually stored on the server.

## CalendarEvent/set

This is a standard "/set" method as described in [@!RFC8620], Section 5.3, with the following extra argument:

- **sendSchedulingMessages**: `Boolean` (default: false)
  If true then any changes to scheduled events will be sent to all the participants (if the server is the origin of the event) or back to the origin (otherwise). If false, the changes only affect this account and no scheduling messages will be sent.

An id may represent a server-expanded single instance of a recurring event if the client asked the server to expand recurrences in "CalendarEvent/query". When the synthetic id for such an instance is given, the server MUST process an update as an update to the recurrence override for that instance on the base event, and a destroy as removing just that instance.

Clients MUST NOT send an update/destroy to both the base event and a synthetic instance in a single "/set" request; the result of this is undefined. Note however, a client may replace a series of explicit instances (each with the same uid but a different `recurrenceId` property) with the base event (same uid, no `recurrenceId`) in a single "/set" call. (So the /set will destroy the existing instances and create the new base event.) This will happen when someone is initially invited to a specific instance or instances of a recurring event, then later invited to the whole series.

Servers MUST enforce the user's permissions as returned in the "myRights" property of the Calendar objects and reject changes with a `forbidden` SetError if not allowed.

The "privacy" property of a JSEvent object allows the principal to override how sharees of the calendar see the event. If this is set to "private", a sharee may not delete or update the event (even if only modifying per-user properties); any attempt to modify such an event MUST be rejected with a `forbidden` SetError. If set to "secret", the server MUST behave as though the event does not exist for all users other than the principal that owns the calendar.

The "privacy" property MUST NOT be set to anything other than "public" (the default) for events in a calendar that does not belong to the user (e.g. a shared team calendar, or a calendar shared by another user). The server MUST reject this with an `invalidProperties` SetError.

If omitted on create, the server MUST set the following properties to an appropriate value:

- @type
- uid
- created

If (and only if) the server is the origin of the event (i.e., the event's "isOrigin" property is true), the "updated" property MUST be set to the current time by the server whenever an event is created or updated. If the client tries to set a value for this property it is not an error, but it MUST be overridden and replaced with the server's time. If the event is being created and the overridden "updated" time is now earlier than a client-supplied "created" time, the "created" time MUST also be overridden to the server's time. If the server is not the origin of the event it MUST NOT automatically set an "updated" time, as this can break correct processing of iTIP messages.

Clients SHOULD NOT allow users to manually edit anything other than per-user
properties when the "isOrigin" property is false, even if the calendar "myRights" allows them to do so. All other properties may be overwritten when a future update arrives to this event from the origin (i.e., via another iTIP REQUEST). Such updates may be directly applied by the server, or applied at the user's request by a client if it has access to the data through some other means (e.g., the client also has access to the user's email and can parse an iMIP message).

When updating an event, if all of:

* a property has been changed other than "calendarIds", "isDraft", "updated" or
  a per-user property (see Section XXX); and
* the server is the origin of the event (the "isOrigin" property is true); and
* the "sequence" property is not explicitly set in the update, or the given
  value is less than or equal to the current "sequence" value on the server;

then the server MUST increment the "sequence" value by one.

The "method" property MUST NOT be set. Any attempt to do so is rejected with a standard `invalidProperties` SetError.

If "utcStart" is set, this is translated into a "start" property using the server's current time zone information. It MUST NOT be set in addition to a "start" property and it cannot be set inside "recurrenceOverrides"; this MUST be rejected with an `invalidProperties` SetError.

Similarly, the "utcEnd" property is translated into a "duration" property if set. It MUST NOT be set in addition to a "duration" property and it cannot be set inside "recurrenceOverrides"; this MUST be rejected with an `invalidProperties` SetError.

The server does not automatically reset the "partipationStatus" or "expectReply" properties of a Participant when changing other event details. Clients should either be intelligent about whether the change invalidates previous RSVPs, or ask the user whether to reset them.

The server MAY enforce that all events have an owner, for example in team calendars. If the user tries to create an event without participants in such a calendar, the server MUST automatically add a participant with the "owner" role corresponding to one of the user's ParticipantIdentities (see Section XXX).

When creating an event with participants, or adding participants to an event that previously did not have participants, the server MUST set the "replyTo" property of the event if not present. Clients SHOULD NOT set the "replyTo" property for events when the user adds participants; the server is better positioned to add all the methods it supports to receive replies.

### Patching

The JMAP "/set" method allows you to update an object by sending a patch, rather than having to supply the whole object. When doing so, care must be taken if updating a property of a CalendarEvent where the value is itself a PatchObject, e.g. inside "localizations" or "recurrenceOverrides". In particular, you cannot add a property with value `null` to the CalendarEvent using a direct patch on that property, as this is interpreted instead as a patch to remove the property.

This is more easily understood with an example. Suppose you have a CalendarEvent object like so:

    {
      "id": "123",
      "title": "FooBar team meeting",
      "start": "2018-01-08T09:00:00",
      "recurrenceRules": [{
       "@type": "RecurrenceRule",
       "frequency": "weekly"
      }],
      "replyTo": {
       "imip": "mailto:6489-4f14-a57f-c1@schedule.example.com"
      },
      "participants": {
       "dG9tQGZvb2Jhci5xlLmNvbQ": {
         "@type": "Participant",
         "name": "Tom",
         "email": "tom@foobar.example.com",
         "scheduleId": "mailto:6489-4f14-a57f-c1@calendar.example.com",
         "sendTo": {
           "imip": "mailto:6489-4f14-a57f-c1@calendar.example.com"
         },
         "participationStatus": "accepted",
         "roles": {
           "attendee": true
         }
       },
       "em9lQGZvb2GFtcGxlLmNvbQ": {
         "@type": "Participant",
         "name": "Zoe",
         "email": "zoe@foobar.example.com",
         "scheduleId": "mailto:zoe@foobar.example.com"
         "sendTo": {
           "imip": "mailto:zoe@foobar.example.com",
           "other": "https://foobar.example.com/zoe/itip"
         },
         "participationStatus": "accepted",
         "roles": {
           "owner": true,
           "attendee": true,
           "chair": true
         }
       },
       "recurrenceOverrides": {
         "2018-03-08T09:00:00": {
           "start": "2018-03-08T10:00:00",
           "participants/dG9tQGZvb2Jhci5xlLmNvbQ/participationStatus":
                                                               "declined"
         }
       }
      }
    }

In this example, Tom is normally going to the weekly meeting but has declined
the occurrence on 2018-03-08, which starts an hour later than normal. Now, if Zoe too were to decline that meeting, she could update the event by just sending a patch like so:

    [[ "CalendarEvent/set", {
      "accountId": "ue150411c",
      "update": {
        "123": {
          "recurrenceOverrides/2018-03-08T09:00:00/
              participants~1em9lQGZvb2GFtcGxlLmNvbQ~1participationStatus":
                  "declined"
        }
      }
    }, "0" ]]

This patches the "2018-03-08T09:00:00" PatchObject in recurrenceOverrides so that it ends up like this:

    "recurrenceOverrides": {
      "2018-03-08T09:00:00": {
        "start": "2018-03-08T10:00:00",
        "participants/dG9tQGZvb2Jhci5xlLmNvbQ/participationStatus":
                                                           "declined",
        "participants/em9lQGZvb2GFtcGxlLmNvbQ/participationStatus":
                                                           "declined"
      }
    }

Now if Tom were to change his mind and remove his declined status override (thus meaning he is attending, as inherited from the top-level event), he might remove his patch from the overrides like so:

    [[ "CalendarEvent/set", {
      "accountId": "ue150411c",
      "update": {
        "123": {
          "recurrenceOverrides/2018-03-08T09:00:00/
              participants~1dG9tQGZvb2Jhci5xlLmNvbQ~1participationStatus": null
        }
      }
    }, "0" ]]

However, if you instead want to remove Tom from this instance altogether, you could not send this patch:

    [[ "CalendarEvent/set", {
      "accountId": "ue150411c",
      "update": {
        "123": {
          "recurrenceOverrides/2018-03-08T09:00:00/
              participants~1dG9tQGZvb2Jhci5xlLmNvbQ": null
        }
      }
    }, "0" ]]

This would mean remove the "participants/dG9tQGZvb2Jhci5xlLmNvbQ" property at path "recurrenceOverrides" -> "2018-03-08T09:00:00" inside the object; but this doesn't exist. We actually we want to add this property and make it map to `null`. The client must instead send the full object that contains the property mapping to `null`, like so:

    [[ "CalendarEvent/set", {
      "accountId": "ue150411c",
      "update": {
        "123": {
          "recurrenceOverrides/2018-03-08T09:00:00": {
            "start": "2018-03-08T10:00:00",
            "participants/em9lQGZvb2GFtcGxlLmNvbQ/participationStatus":
                                                           "declined"
            "participants/dG9tQGZvb2Jhci5xlLmNvbQ": null
          }
        }
      }
    }, "0" ]]


### Sending invitations and responses

If "sendSchedulingMessages" is true, the server MUST send appropriate iTIP [@!RFC5546] scheduling messages after successfuly creating, updating or destroying a calendar event.

When determining which scheduling messages to send, the server must first establish whether it is the *origin* of the event, as described in the "isOrigin" property.

Messages are only sent to participants with a "scheduleAgent" property set to "server" or omitted. If the effective "scheduleAgent" property is changed:

- to "server" from something else: send messages to this participant as though
  the event had just been created.
- from "server" to something else: send messages to this participant as though
  the event had just been destroyed.
- any other change: do not send any messages to this participant.

The server may send the scheduling message via any of the methods defined on the sendTo property of a participant (if the server is the origin) or the replyTo property of the event (otherwise) that it supports. If no supported methods are available, the server MUST reject the change with a `noSupportedScheduleMethods` SetError.

If the server is the origin of the event it MUST NOT send messages to any participant where it will receive the message back in the same account (i.e. it must not send messages to the owner of the calendar the event is already on).

If sending via iMIP [@?RFC6047], the server MAY choose to only send updates it deems "essential" to avoid flooding the recipient's email with changes they do not care about. For example, changes to the participation status of another participant, or changes to events solely in the past may be omitted.

#### REQUEST

When the server is the origin for the event, a REQUEST message ([@!RFC5546], Section 3.2.2) is sent to all current participants (except those corresponding to the owner of the calendar) if either:

- The event is being created; or
- Any non per-user property (see Section XXX) is updated on the event
  (including adding/removing participants), except if just modifying the recurrenceOverrides such that CANCEL messages are generated (see the next section).

Note, if the only change is adding an additional instance (not generated by the event's recurrence rule) to the recurrenceOverrides, this MAY be handled via sending an ADD message ([@!RFC5546], Section 3.2.4) for the single instance rather than a REQUEST message for the base event. However, for interoperability reasons this is not recommended due to poor support in the wild for this type of message.

The server MUST ensure participants are only sent information about recurrence instances they are added to when sending scheduling messages for recurring events. If the participant is not invited to the full recurring event but only individual instances, scheduling messages MUST be sent for just those expanded occurrences individually. If a participant is invited to a recurring event, but removed via a recurrence override from a particular instance, any scheduling messages to this participant MUST return the instance as "excluded" (if it matches a recurrence rule for the event) or omit the instance entirely (otherwise).

If the event's "hideAttendees" property is set to `true`, the recipient MUST be the only attendee in the message; all others are omitted.

#### CANCEL

When the server is the origin for the event, a CANCEL message ([@!RFC5546], Section 3.2.5) is sent if any of:

- A participant is removed from either the base event or a single instance
  (the message is only sent to this participant; remaining participants will get a REQUEST, as described above).
- The event is destroyed.
- An exclusion is added to recurrenceOverrides to remove an instance generated
  by the event's recurrence rule.
- An additional instance (not generated by the event's recurrence rule) is
  removed from the recurrenceOverrides.

In each of the latter 3 cases, the message is sent to all participants (except those corresponding to the owner of the calendar).

#### REPLY

When the server is *not* the origin for the event, a REPLY message ([@!RFC5546], Section 3.2.3) is sent for every participant corresponding to one of the user's ParticipantIdentitities in the account if any of the following changes are made:

- The "participationStatus" property of the participant is changed, either for
  the base event or a specific instance, to any value other than "needs-action".
- The event is created and the participationStatus is not "needs-action".
- The event is destroyed and the participationStatus was not "needs-action".

If the participationStatus property is changed for just a single instance of the event (i.e., set in recurrenceOverrides), the REPLY message SHOULD be sent for just that recurrence id.

## CalendarEvent/copy

This is a standard "/copy" method as described in [@!RFC8620], Section 5.4.

## CalendarEvent/query

This is a standard "/query" method as described in [@!RFC8620], Section 5.5, with two extra arguments:

- **expandRecurrences**: `Boolean` (default: false)
  If true, the server will expand any recurring event. If true, the filter MUST be just a FilterCondition (not a FilterOperator) and MUST include both a before and after property. This ensures the server is not asked to return an infinite number of results.
- **timeZone**: `String`
  The time zone for before/after filter conditions (default: "Etc/UTC")

If expandRecurrences is true, a separate id will be returned for each instance of a recurring event that matches the query. This synthetic id is opaque to the client, but allows the server to resolve the id + recurrence id for "/get" and "/set" operations. Otherwise, a single id will be returned for matching recurring events that represents the entire event.

There is no necessary correspondence between the ids of different instances of the same expanded event.

The following additional error may be returned instead of the "CalendarEvent/query" response:

`cannotCalculateOccurrences`: the server cannot expand a recurrence required to return the results for this query.

### Filtering

A **FilterCondition** object has the following properties:

- **inCalendars**: `Id[]|null`
  A list of calendar ids. An event must be in ANY of these calendars to match the condition.
- **after**: `LocalDate|null`
  The end of the event, or any recurrence of the event, in the time zone given as the timeZone argument, must be after this date to match the condition.
- **before**: `LocalDate|null`
  The start of the event, or any recurrence of the event, in the time zone given as the timeZone argument, must be before this date to match the condition.
- **text**: `String|null`
  Looks for the text in the *title*, *description*, *locations* (matching name/description), *participants* (matching name/email) and any other textual properties of the event or any recurrence of the event.
- **title**: `String|null`
  Looks for the text in the *title* property of the event, or the overridden *title* property of a recurrence.
- **description**: `String|null`
  Looks for the text in the *description* property of the event, or the overridden *description* property of a recurrence.
- **location**: `String|null`
  Looks for the text in the *locations* property of the event (matching name/description of a location), or the overridden *locations* property of a recurrence.
- **owner**: `String|null`
  Looks for the text in the name or email fields of a participant in the *participants* property of the event, or the overridden *participants* property of a recurrence, where the participant has a role of "owner".
- **attendee**: `String|null`
  Looks for the text in the name or email fields of a participant in the *participants* property of the event, or the overridden *participants* property of a recurrence, where the participant has a role of "attendee".
- **participationStatus**: Must match. If owner/attendee condition, status must
  be of that participant. Otherwise any.
- **uid**: `String`
  The uid of the event is exactly the given string.

If expandRecurrences is true, all conditions must match against the same instance of a recurring event for the instance to match. If expandRecurrences is false, all conditions must match, but they may each match any instance of the event.

If zero properties are specified on the FilterCondition, the condition MUST always evaluate to `true`. If multiple properties are specified, ALL must apply for the condition to be `true` (it is equivalent to splitting the object into one-property conditions and making them all the child of an AND filter operator).

The exact semantics for matching `String` fields is **deliberately not defined** to allow for flexibility in indexing implementation, subject to the following:

- Text SHOULD be matched in a case-insensitive manner.
- Text contained in either (but matched) single or double quotes SHOULD be treated as a **phrase search**, that is a match is required for that exact sequence of words, excluding the surrounding quotation marks. Use `\"`, `\'` and `\\` to match a literal `"`, `'` and `\` respectively in a phrase.
- Outside of a phrase, white-space SHOULD be treated as dividing separate tokens that may be searched for separately in the event, but MUST all be present for the event to match the filter.
- Tokens MAY be matched on a whole-word basis using stemming (so for example a text search for `bus` would match "buses" but not "business").

### Sorting

The following properties MUST be supported for sorting:

- start
- uid
- recurrenceId

The following properties SHOULD be supported for sorting:

- created
- updated

## CalendarEvent/queryChanges

This is a standard "/queryChanges" method as described in [@!RFC8620], Section 5.6.

## CalendarEvent/parse

This method allows the client to parse blobs as `iCalendars` [@!RFC5545] to get `CalendarEvent` objects. This can
be used to parse and display calendar events information to the end user.

The following metadata properties on the CalendarEvent objects will be `null` if requested:

- id
- baseEventId
- calendarIds
- isDraft
- isOrigin

The *CalendarEvent/parse* method takes the following arguments:

- **accountId**: `Id`
  The id of the account to use.
- **blobIds**: `Id[]`
  The ids of the blobs to parse.
- **properties**: `String[]`
  If supplied, only the properties listed in the array are returned for each `CalendarEvent` object. If omitted, defaults to all the properties.

The response object contains the following arguments:

- **accountId**: `Id`
  The id of the account used for the call.
- **parsed**: `Id[CalendarEvent[]]|null`
  A map of blob ids to parsed `CalendarEvent` objects representations for each successfully parsed blob, or `null` if none.
- **notFound**: `Id[]|null`
  A list of blob ids given that could not be found, or `null` if none.
- **notParsable**: `Id[]|null`
  A list of blob ids given that corresponded to blobs that could not be parsed as CalendarEvents, or `null` if none.

Parsed `iCalendars` are to be converted into `CalendarEvent` objects following the process defined in the
[JSCalendar: Converting from and to iCalendar](https://datatracker.ietf.org/doc/draft-ietf-calext-jscalendar-icalendar) draft.