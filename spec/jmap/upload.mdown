# Binary data

Binary data is referenced by a *blobId* in JMAP, and uploaded/downloaded separately to the core API. A blobId does not have a name inherent to it, but this is normally given in the same object that contains the blobId. The data represented by a blobId is immutable.

Any blobId that exists within an account may be used when creating/updating another object in that account. For example, an Email type may have a blobId that represents the RFC5322 representation of the message. A client could create a new Email object with an attachment and use this blobId, in effect attaching the old message to the new one. Similarly it could attach any existing existing attachment of an old message without having to download and upload it again.

When the client uses a blobId in a create/update, the server MAY assign a new blobId to refer to the same binary data from the new/updated object. If it does so, it MUST return any properties that contain a changed blobId in the created/updated response so the client gets the new ids.

A blob that is not referenced by a JMAP object (e.g. as a message attachment), MAY be deleted by the server to free up resources. Uploads (see below) are initially unreferenced blobs. To ensure interoperability:

* The server SHOULD use a separate quota for unreferenced blobs to the user's
  usual quota.
* This quota SHOULD be at least the maximum total size that a single
  object can reference on this server. For example, if supporting JMAP Mail, this should be at least the maximum total attachments size for a message.
* When an upload would take the user over quota, the server MUST delete
  unreferenced blobs in date order, oldest first, until there is room for the new blob.
* Except where quota restrictions force early deletion, an unreferenced blob
  SHOULD NOT be deleted for at least 24h from the time of upload; if reuploaded, the same blobId MAY be returned, but this SHOULD reset the expiry time.
* A blob MUST NOT be deleted during the method call which removed the last
  reference, so that a client can issue a create and a destroy that both reference the blob within the same method call.

## Uploading binary data

There is a single endpoint which handles all file uploads, regardless of what they are to be used for. To upload a file, the client submits a POST request to the file upload endpoint (see the authentication section for information on how to obtain this URL). The Content-Type MUST be correctly set for the type of the file being uploaded. The request MUST be authenticated as per any HTTP request. The request MAY include an `X-JMAP-AccountId` header, with the value being the account to use for the request. Otherwise, the default account will be used.

The server will respond with one of the following HTTP response codes:

### 201: File uploaded successfully

The content of the response is a single JSON object with the following properties:

- **accountId**: `String`
  The id of the account used for the call.
- **blobId**: `String`,
  The id representing the binary data uploaded. The data for this id is immutable. The id *only* refers to the binary data, not any metadata.
- **type**: `String`
  The media type of the file, as specified in [@!RFC6838], section 4.2.
- **size**: `Number`
  The size of the file in bytes.

If identical binary content to an existing blob in the account is uploaded, the existing blobId MAY be returned.

### 400: Bad request

The request was malformed (this includes the case where an `X-JMAP-AccountId` header is sent with a value that does not exist). The client SHOULD NOT retry the same request. There is no content in the response.

### 401: Unauthorized

The `Authorization` header was missing or did not contain a valid token. Reauthenticate and then retry the request. As per the HTTP spec, the response MUST have a `WWW-Authenticate` header listing the available authentication schemes. There is no content in the response.

### 404: Not Found

The upload endpoint has moved. See the Authentication section of the spec for how to rediscover the current URL to use. There is no content in the response.

### 413: Request Entity Too Large

The file is larger than the maximum size the server is willing to accept for a single file. The client SHOULD NOT retry uploading the same file. There is no content in the response. The client may discover the maximum size the server is prepared to accept by inspecting the server *capabilities* object, returned with the successful authentication response.

### 415: Unsupported Media Type

The server MAY choose to not allow certain content types to be uploaded, such as executable files. This error response is returned if an unacceptable type is uploaded. The client SHOULD NOT retry uploading the same file. There is no content in the response.

### 429: Rate limited

Returned if the client has made too many upload requests recently, or has too many concurrent uploads currently in progress. Clients SHOULD wait a while then try again. The response MAY include a `Retry-After` header indicating how long to wait before making a new request. There is no content in the response.

### 503: Service Unavailable

The server is currently down. The client should try again later with exponential backoff. There is no content in the response.
